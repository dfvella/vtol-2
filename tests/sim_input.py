#!/usr/bin/env python3

# A script for generating sim_input.h header file from a series of points

from sys import argv
from math import sqrt, sin, cos, pi

USAGE = f'usage: {argv[0]} <input file> <output file>'
LOOP_FREQ = 50 # Hz
SIM_TIME = 10 # sec
INPUT_SIZE = SIM_TIME * LOOP_FREQ
INDEX_TIME = 0
INDEX_THRO = 1
INDEX_AILE = 2
INDEX_ELEV = 3
INDEX_RUDD = 4
INDEX_GEAR = 5
INDEX_AUX1 = 6
INDEX_ROLL = 7
INDEX_PITCH = 8
INDEX_YAW = 9
INDEX_FLAGS = 10

RADIANS_PER_DEGREE = pi / 180

SIM_INPUT_H_PRE = f'''#ifndef __SIM_INPUT_H__
#define __SIM_INPUT_H__

// file generated by {argv[0]}

#include "flight_controller.h"

#define SIM_INPUT_SIZE {INPUT_SIZE}

Fc_Input sim_input[SIM_INPUT_SIZE] = {{
'''

SIM_INPUT_H_POST = '''};
#endif // __SIM_INPUT_H__
'''

class Quaternion:
    def __init__(self, w:float=0.7071, x:float=0.70710,
                       y:float=0.00001, z:float=0.00001) -> None:
        self.w = w
        self.x = x
        self.y = y
        self.z = z
    def __mul__(self, other:'Quaternion') -> 'Quaternion':
        assert(type(other) == Quaternion)
        res = Quaternion(
            self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z,
            self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y,
            self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x,
            self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w
        )
        res.normalize()
        return res
    def normalize(self) -> None:
        l = sqrt(self.w**2 + self.x**2 + self.y**2 + self.z**2)
        self.w /= l
        self.x /= l
        self.y /= l
        self.z /= l
    def rotate_roll(self, angle:float) -> None:
        rotation = Quaternion(
            cos(angle * RADIANS_PER_DEGREE * 0.5),
            sin(angle * RADIANS_PER_DEGREE * 0.5),
            0.0001,
            0.0001
        )
        result = self * rotation
        self.w = result.w
        self.x = result.x
        self.y = result.y
        self.z = result.z
    def rotate_pitch(self, angle:float) -> None:
        rotation = Quaternion(
            cos(angle * RADIANS_PER_DEGREE * 0.5),
            0.0001,
            sin(angle * RADIANS_PER_DEGREE * 0.5),
            0.0001
        )
        result = self * rotation
        self.w = result.w
        self.x = result.x
        self.y = result.y
        self.z = result.z
    def rotate_yaw(self, angle:float) -> None:
        rotation = Quaternion(
            cos(angle * RADIANS_PER_DEGREE * 0.5),
            0.0001,
            0.0001,
            sin(angle * RADIANS_PER_DEGREE * 0.5)
        )
        result = self * rotation
        self.w = result.w
        self.x = result.x
        self.y = result.y
        self.z = result.z

def check_args() -> None:
    if len(argv) != 3:
        exit(USAGE)

def interpolate(val:float, a:float, b:float, x:float, y:float) -> float:
    return (((val - a) / (b - a)) * (y - x)) + x

def gen_input() -> None:
    with open(argv[1], 'r') as f:
        a = f.read().splitlines()

    start = float(a[0].split()[0])
    stop = float(a[-1].split()[0])

    if start != 0:
        exit('error: first data point must be at time 0')
    if stop != SIM_TIME:
        exit(f'error: last data point must be at time {SIM_TIME}')

    b = [ elem for elem in a ]
    b.pop(0)

    with open(argv[2], 'w') as f:
        f.write(SIM_INPUT_H_PRE)

        count = 1

        for first, second in zip(a,b):
            first = [ float(elem) for elem in first.split() ]
            second = [ float(elem) for elem in second.split() ]

            start = first[INDEX_TIME] * LOOP_FREQ
            stop = second[INDEX_TIME] * LOOP_FREQ

            if start % 1:
                exit(f'error: invalid time (line {count})')
            if stop % 1:
                exit(f'error: invalid time (line {count})')

            start = int(start)
            stop = int(stop)

            for t in range(start, stop):
                t /= LOOP_FREQ

                f.write('    { ')

                for x, y in zip(first[INDEX_THRO:INDEX_AUX1+1], second[INDEX_THRO:INDEX_AUX1+1]):
                    out = interpolate(t, first[INDEX_TIME], second[INDEX_TIME], x, y)
                    f.write(f'{out:.3f}, ')

                diffs = 0
                for x, y in zip(first[INDEX_ROLL:INDEX_YAW+1], second[INDEX_ROLL:INDEX_YAW+1]):
                    if x != y:
                        diffs += 1
                if diffs > 1:
                    exit(f'error: invalid orientation change (line {count})')

                q = Quaternion()

                x, y = first[INDEX_ROLL], second[INDEX_ROLL]
                roll = interpolate(t, first[INDEX_TIME], second[INDEX_TIME], x, y)
                if roll: q.rotate_roll(roll)

                x, y = first[INDEX_PITCH], second[INDEX_PITCH]
                pitch = interpolate(t, first[INDEX_TIME], second[INDEX_TIME], x, y)
                if pitch: q.rotate_pitch(pitch)

                x, y = first[INDEX_YAW], second[INDEX_YAW]
                yaw = interpolate(t, first[INDEX_TIME], second[INDEX_TIME], x, y)
                if yaw: q.rotate_yaw(yaw)

                f.write(f'{{ {q.w:.5f}, {q.x:.5f}, {q.y:.5f}, {q.z:.5f} }}, ')
                f.write(f'{int(first[INDEX_FLAGS])} }}')

                if count == INPUT_SIZE:
                    newline = '\n'
                else:
                    newline = ',\n'
                f.write(newline)
                count += 1
        f.write(SIM_INPUT_H_POST)

def main() -> None:
    check_args()
    gen_input()

if __name__ == '__main__':
    main()
